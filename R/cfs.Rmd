---
title: "R Notebook"
output: html_notebook
---


```{r}
install.packages("devtools")
install.packages("bigchess")
install.packages("fastDummies")
install.packages("lemon")
install.packages("stringr")
install.packages("rchess")
devtools::install_github("dandls/counterfactuals")
```

```{r}
library(counterfactuals)
library(iml)
library(bigchess)
library(stringr)
library(rchess)
library(lemon)
library(comprehenr)
library(fastDummies)
library(methods)
library(reticulate)
```


```{r}
CODE_TO_PIECE <- c('P', 'N', 'B', 'R', 'Q', 'K', 'p', 'n', 'b', 'r', 'q', 'k')
ROWS <- c(1, 2, 3, 4, 5, 6, 7, 8)
FILES <- c("a", "b", "c", "d", "e", "f", "g", "h")
SQUARE_NAMES <- to_vec(for (i in FILES) for (j in ROWS) paste(i, as.character(j), sep=""))

```

```{python}
ROWS = [1, 2, 3, 4, 5, 6, 7, 8]
FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
SQUARE_NAMES = [f + str(r) for r in ROWS for f in FILES]
ACTION_NAMES = [s1 + s2 for s1 in SQUARE_NAMES for s2 in SQUARE_NAMES if s1 != s2] + [''] # adding impossible situation
PROMOTIONAL_MOVES = [f + str(r) + f1 + str(r - 1) for f in FILES for f1 in FILES for r in [2] if abs(ord(f)-ord(f)) <= 1] + \
                    [f + str(r) + f1 + str(r + 1) for f in FILES for f1 in FILES for r in [7] if abs(ord(f)-ord(f)) <= 1]
PROMOTIONAL_PIECES = ['r', 'b', 'n', 'q', 'R', 'B', 'N', 'Q']
ACTION_NAMES += [m + p for m in PROMOTIONAL_MOVES for p in PROMOTIONAL_PIECES]
```

```{r}
ACTION_NAMES <- py$ACTION_NAMES
```

```{r}
engine_path <- "C:\\Users\\Jasmina\\Documents\\PhD\\CARLA\\engines\\chess\\stockfish_14.1\\stockfish_14.1"
data_path <- "C:\\Users\\Jasmina\\Documents\\PhD\\CARLA\\data\\chess\\dataset.csv"
```

```{r}
# loading engine
eng <- uci_engine(engine_path)
```

```{r}
# checks whether fen represents a valid board
is_valid_fen <- function(fen){
  if (str_count(fen, "K") != 1) {
    return(0)
  }
  if (str_count(fen, "k") != 1) {
    return(0)
  }
  if (str_count(fen, "P") > 8) {
    return(0)
  }
  if (str_count(fen, "p") > 8) {
    return(0)
  }
  
  tokens <- str_split(fen, "/")[[1]]
  first_row <- tokens[1]
  last_row <- tokens[8]
  
  if (str_count(first_row, "p") > 0) {
    return(0)
  }
  if (str_count(last_row, "p") > 0) {
    return(0)
  }
  if (str_count(first_row, "P") > 0) {
    return(0)
  }
  if (str_count(last_row, "P") > 0) {
    return(0)
  }
  
  fen_pos <- Chess$new(fen)
  if (length(fen_pos$moves()) == 0) {
    return(0)
  }
  
  alt_fen <- str_replace(fen, 'w', 'b') # TODO: fix this -- to work the other way too
  print(alt_fen)
  b <- Chess$new(alt_fen)
  if (b$in_check()) {
    print("check")
    return(0)
  }
  
  return(1)
}
```

```{r}
# extracts best move as string from engine's response
get_best_move <- function(position_fen) {
  print(position_fen)
  if (is_valid_fen(position_fen) == 1) {
    # loading engine
    eng <- uci_engine(engine_path)
    eng <- uci_position(eng, fen=position_fen)
    str_move <- uci_go(eng, depth=10)
    str_move <- tail(str_move$temp, n=1)
    tokens <- str_split(str_move, " ")
    best_move <- tokens[[1]][2]
  } else {
    print("Invalid position")
    best_move <- " "
  }
  print(best_move)
  return(best_move)
}
```
```{r}
# function to transform board to fen string
from_board_to_fen <- function(board) {
  print(board)
  num_rows <- 8
  fen <- ""
  r <- 0
  
  while (r < num_rows){
    c <- 0
    while (c < num_rows) {
      curr_index <- num_rows * (7-r) + c 
      
      if (as.integer(as.character(board[[curr_index + 1]])) == 0) {
        blank_counter <- 0
        
        while (as.integer(as.character(board[[curr_index + 1]])) == 0) {
          blank_counter <- blank_counter + 1
          c <- c + 1
          if (c >= num_rows) {
            break
          }
          
          curr_index <- num_rows * (7-r) + c
        }
        
        fen <- paste(fen, as.character(blank_counter), sep="")
      }
      else {
        code <- CODE_TO_PIECE[as.integer(as.character(board[[curr_index + 1]]))]
        fen <- paste(fen, as.character(code), sep="")
        c <- c + 1
      }
    }
    
    r <- r + 1
    if (r < num_rows){
      fen <- paste(fen, "/", sep="")
    }
  }
  
  player_num <- board[[65]]
  player <- " w "
  if (player_num == 1) {
    player <- " b "  
  }
  
  fen <- paste(fen, player, sep="")

  fen <- paste(fen, "- - 0 1", sep="")
  
  return(fen)
}
```


```{r}
# loading chess data
chess_data <- read.csv(file=data_path)
chess_data <- chess_data[0:10000,-1]
knit_print.data.frame <- lemon_print
col_names <- colnames(chess_data)

head(chess_data)
```


```{r}
# turn categorical variables into factors
# for (c_name in colnames(chess_data)) {
#   chess_data[, c_name] <- as.factor(chess_data[, c_name])
# }

chess_data["target"] <- apply(chess_data, 1, function(x) which(ACTION_NAMES == x['best_move']))

tail(chess_data)
```

```{r}
split <- function(string) {
  tokens <- str_split(string, "_")
  return(as.integer(tokens[[1]][2]))
}
```


```{r}
board_df <- chess_data[2, ]
head(board_df)
fact_fen <- from_board_to_fen(board_df)
print(fact_fen)
```

```{r}
library("methods")

# create bb model class
model_class <- setRefClass("model_class", fields=list(task="character"), methods=list(
  get_pred = function(model, newdata) {
    n <- nrow(newdata)
    i <- 1
    y_hat <- matrix(0, nrow=n, ncol=length(ACTION_NAMES))
    
    while (i <= n) {
      cf <- newdata[i,]
      fen_board <- from_board_to_fen(cf)
      best_move <- get_best_move(fen_board)
      best_move_pos <- which(ACTION_NAMES == best_move)
      
      #y_hat[i] <- best_move
      y_hat[i, best_move_pos] <- 1
      i <- i + 1
    }
    y_hat <- data.frame(y_hat)
    names(y_hat) <- ACTION_NAMES
    return(y_hat)
  }
))
```

```{r}
# define model
bb_model <- model_class(task="classification")
```

```{r}
# define predictor
predictor <- Predictor$new(bb_model, data=chess_data, predict.function=bb_model$get_pred, y="best_move")
predictor$task <- "classification"
predictor$batch.size <- 100
```

```{r}
# def cf method
cf_classif <- MOCClassif$new(predictor, n_generations = 20, fixed_features = c("player"), max_changed = 2)
```

```{r}
# find counterfactuals
cfactuals <- cf_classif$find_counterfactuals(
  board_df, desired_class = "c4c8"
)
```


```{r}
cfactuals$data
n_cfs <- nrow(cfactuals$data)
print('Counterfactuals:')
for (i in 1:n_cfs) {
  cf <- cfactuals$data[i]
  cf_fen <- from_board_to_fen(cf)
  print(cf_fen)
}
```

```{r}
uci_quit(eng)
```







